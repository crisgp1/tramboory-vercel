import mongoose, { Schema, Document } from 'mongoose';
import { AlertType, AlertPriority } from '@/types/inventory';

// Interface para el documento de InventoryAlert
export interface IInventoryAlert extends Document {
  alertId: string;
  type: AlertType;
  priority: AlertPriority;
  productId: mongoose.Types.ObjectId;
  locationId?: string;
  batchId?: string;
  title: string;
  message: string;
  threshold?: number;
  currentValue?: number;
  unit?: string;
  expiryDate?: Date;
  isActive: boolean;
  isAcknowledged: boolean;
  acknowledgedBy?: string;
  acknowledgedAt?: Date;
  acknowledgedNotes?: string;
  autoGenerated: boolean;
  notificationsSent: {
    email: boolean;
    push: boolean;
    inApp: boolean;
    lastSentAt?: Date;
  };
  metadata?: Record<string, any>;
  createdBy: string;
  createdAt: Date;
  updatedAt: Date;
}

// Sub-esquema para notificaciones
const NotificationsSchema = new Schema({
  email: {
    type: Boolean,
    default: false
  },
  push: {
    type: Boolean,
    default: false
  },
  inApp: {
    type: Boolean,
    default: false
  },
  lastSentAt: {
    type: Date
  }
}, { _id: false });

// Schema principal de InventoryAlert
const InventoryAlertSchema = new Schema<IInventoryAlert>({
  alertId: {
    type: String,
    required: true,
    unique: true,
    index: true
  },
  type: {
    type: String,
    required: true,
    enum: Object.values(AlertType),
    index: true
  },
  priority: {
    type: String,
    required: true,
    enum: Object.values(AlertPriority),
    index: true
  },
  productId: {
    type: Schema.Types.ObjectId,
    required: true,
    ref: 'Product',
    index: true
  },
  locationId: {
    type: String,
    trim: true,
    index: true
  },
  batchId: {
    type: String,
    trim: true,
    index: true
  },
  title: {
    type: String,
    required: true,
    trim: true,
    maxlength: 200
  },
  message: {
    type: String,
    required: true,
    trim: true,
    maxlength: 1000
  },
  threshold: {
    type: Number,
    min: 0
  },
  currentValue: {
    type: Number,
    min: 0
  },
  unit: {
    type: String,
    trim: true
  },
  expiryDate: {
    type: Date,
    index: true
  },
  isActive: {
    type: Boolean,
    required: true,
    default: true,
    index: true
  },
  isAcknowledged: {
    type: Boolean,
    required: true,
    default: false,
    index: true
  },
  acknowledgedBy: {
    type: String,
    index: true
  },
  acknowledgedAt: {
    type: Date,
    index: true
  },
  acknowledgedNotes: {
    type: String,
    trim: true,
    maxlength: 500
  },
  autoGenerated: {
    type: Boolean,
    required: true,
    default: true,
    index: true
  },
  notificationsSent: {
    type: NotificationsSchema,
    required: true,
    default: () => ({
      email: false,
      push: false,
      inApp: false
    })
  },
  metadata: {
    type: Schema.Types.Mixed,
    default: {}
  },
  createdBy: {
    type: String,
    required: true,
    index: true
  }
}, {
  timestamps: true,
  collection: 'inventory_alerts'
});

// Índices compuestos
InventoryAlertSchema.index({ productId: 1, type: 1, isActive: 1 });
InventoryAlertSchema.index({ priority: 1, isActive: 1, createdAt: -1 });
InventoryAlertSchema.index({ isActive: 1, isAcknowledged: 1, priority: 1 });
InventoryAlertSchema.index({ type: 1, isActive: 1, createdAt: -1 });
InventoryAlertSchema.index({ locationId: 1, isActive: 1 });
InventoryAlertSchema.index({ expiryDate: 1, type: 1 });
InventoryAlertSchema.index({ autoGenerated: 1, isActive: 1 });

// Validaciones personalizadas
InventoryAlertSchema.pre('validate', function(next) {
  // Validar campos específicos según el tipo de alerta
  switch (this.type) {
    case AlertType.LOW_STOCK:
    case AlertType.REORDER_POINT:
      if (this.threshold === undefined || this.currentValue === undefined) {
        this.invalidate('threshold', 'Threshold y currentValue son requeridos para alertas de stock');
        this.invalidate('currentValue', 'Threshold y currentValue son requeridos para alertas de stock');
      }
      if (!this.unit) {
        this.invalidate('unit', 'La unidad es requerida para alertas de stock');
      }
      break;

    case AlertType.EXPIRY_WARNING:
    case AlertType.EXPIRED_PRODUCT:
      if (!this.expiryDate) {
        this.invalidate('expiryDate', 'La fecha de caducidad es requerida para alertas de caducidad');
      }
      if (!this.batchId) {
        this.invalidate('batchId', 'El ID del lote es requerido para alertas de caducidad');
      }
      break;

    case AlertType.QUARANTINE_ALERT:
      if (!this.batchId) {
        this.invalidate('batchId', 'El ID del lote es requerido para alertas de cuarentena');
      }
      break;
  }

  // Validar que si está reconocida, tenga los campos requeridos
  if (this.isAcknowledged) {
    if (!this.acknowledgedBy) {
      this.invalidate('acknowledgedBy', 'acknowledgedBy es requerido cuando la alerta está reconocida');
    }
    if (!this.acknowledgedAt) {
      this.acknowledgedAt = new Date();
    }
  }

  next();
});

// Middleware pre-save
InventoryAlertSchema.pre('save', function(next) {
  // Auto-generar título si no está definido
  if (!this.title) {
    this.title = (this as any).generateTitle();
  }

  // Auto-generar mensaje si no está definido
  if (!this.message) {
    this.message = (this as any).generateMessage();
  }

  next();
});

// Métodos de instancia
InventoryAlertSchema.methods.generateTitle = function(): string {
  switch (this.type) {
    case AlertType.LOW_STOCK:
      return 'Stock Bajo';
    case AlertType.REORDER_POINT:
      return 'Punto de Reorden Alcanzado';
    case AlertType.EXPIRY_WARNING:
      return 'Producto Próximo a Caducar';
    case AlertType.EXPIRED_PRODUCT:
      return 'Producto Caducado';
    case AlertType.QUARANTINE_ALERT:
      return 'Producto en Cuarentena';
    default:
      return 'Alerta de Inventario';
  }
};

InventoryAlertSchema.methods.generateMessage = function(): string {
  switch (this.type) {
    case AlertType.LOW_STOCK:
      return `El stock actual (${this.currentValue} ${this.unit}) está por debajo del mínimo (${this.threshold} ${this.unit})`;
    case AlertType.REORDER_POINT:
      return `Se ha alcanzado el punto de reorden (${this.threshold} ${this.unit}). Stock actual: ${this.currentValue} ${this.unit}`;
    case AlertType.EXPIRY_WARNING:
      const daysToExpiry = this.expiryDate ? Math.ceil((this.expiryDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24)) : 0;
      return `El lote ${this.batchId} caduca en ${daysToExpiry} días (${this.expiryDate?.toLocaleDateString()})`;
    case AlertType.EXPIRED_PRODUCT:
      return `El lote ${this.batchId} ha caducado (${this.expiryDate?.toLocaleDateString()})`;
    case AlertType.QUARANTINE_ALERT:
      return `El lote ${this.batchId} ha sido puesto en cuarentena`;
    default:
      return 'Se ha generado una alerta de inventario';
  }
};

InventoryAlertSchema.methods.acknowledge = function(userId: string, notes?: string) {
  this.isAcknowledged = true;
  this.acknowledgedBy = userId;
  this.acknowledgedAt = new Date();
  if (notes) {
    this.acknowledgedNotes = notes;
  }
  return this.save();
};

InventoryAlertSchema.methods.dismiss = function() {
  this.isActive = false;
  return this.save();
};

InventoryAlertSchema.methods.markNotificationSent = function(channel: 'email' | 'push' | 'inApp') {
  this.notificationsSent[channel] = true;
  this.notificationsSent.lastSentAt = new Date();
  return this.save();
};

InventoryAlertSchema.methods.shouldSendNotification = function(channel: 'email' | 'push' | 'inApp'): boolean {
  if (!this.isActive || this.isAcknowledged) return false;
  
  // Si ya se envió, verificar cooldown
  if (this.notificationsSent[channel] && this.notificationsSent.lastSentAt) {
    const hoursSinceLastSent = (Date.now() - this.notificationsSent.lastSentAt.getTime()) / (1000 * 60 * 60);
    const cooldownHours = this.getCooldownHours();
    return hoursSinceLastSent >= cooldownHours;
  }
  
  return true;
};

InventoryAlertSchema.methods.getCooldownHours = function(): number {
  switch (this.priority) {
    case AlertPriority.CRITICAL:
      return 1; // 1 hora
    case AlertPriority.HIGH:
      return 4; // 4 horas
    case AlertPriority.MEDIUM:
      return 12; // 12 horas
    case AlertPriority.LOW:
      return 24; // 24 horas
    default:
      return 24;
  }
};

InventoryAlertSchema.methods.escalate = function() {
  const priorityOrder = [AlertPriority.LOW, AlertPriority.MEDIUM, AlertPriority.HIGH, AlertPriority.CRITICAL];
  const currentIndex = priorityOrder.indexOf(this.priority);
  
  if (currentIndex < priorityOrder.length - 1) {
    this.priority = priorityOrder[currentIndex + 1];
    // Reset notifications para que se envíen con la nueva prioridad
    this.notificationsSent = {
      email: false,
      push: false,
      inApp: false
    };
    return this.save();
  }
  
  return Promise.resolve(this);
};

// Métodos estáticos
InventoryAlertSchema.statics.findActive = function() {
  return this.find({ isActive: true })
    .sort({ priority: 1, createdAt: -1 })
    .populate('productId');
};

InventoryAlertSchema.statics.findByPriority = function(priority: AlertPriority) {
  return this.find({ isActive: true, priority })
    .sort({ createdAt: -1 })
    .populate('productId');
};

InventoryAlertSchema.statics.findByType = function(type: AlertType) {
  return this.find({ isActive: true, type })
    .sort({ priority: 1, createdAt: -1 })
    .populate('productId');
};

InventoryAlertSchema.statics.findByProduct = function(productId: string) {
  return this.find({ productId, isActive: true })
    .sort({ priority: 1, createdAt: -1 });
};

InventoryAlertSchema.statics.findUnacknowledged = function() {
  return this.find({ isActive: true, isAcknowledged: false })
    .sort({ priority: 1, createdAt: -1 })
    .populate('productId');
};

InventoryAlertSchema.statics.findPendingNotifications = function(channel: 'email' | 'push' | 'inApp') {
  const query: any = {
    isActive: true,
    isAcknowledged: false
  };
  
  query[`notificationsSent.${channel}`] = false;
  
  return this.find(query)
    .sort({ priority: 1, createdAt: -1 })
    .populate('productId');
};

InventoryAlertSchema.statics.findExpiredAlerts = function(days: number = 30) {
  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - days);
  
  return this.find({
    isActive: true,
    createdAt: { $lt: cutoffDate }
  });
};

InventoryAlertSchema.statics.createLowStockAlert = function(
  productId: string,
  locationId: string,
  currentStock: number,
  threshold: number,
  unit: string,
  createdBy: string
) {
  const alertData = {
    alertId: `ALERT-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    type: AlertType.LOW_STOCK,
    priority: currentStock <= threshold * 0.5 ? AlertPriority.HIGH : AlertPriority.MEDIUM,
    productId,
    locationId,
    threshold,
    currentValue: currentStock,
    unit,
    createdBy,
    autoGenerated: true
  };
  
  return this.create(alertData);
};

InventoryAlertSchema.statics.createExpiryAlert = function(
  productId: string,
  locationId: string,
  batchId: string,
  expiryDate: Date,
  daysUntilExpiry: number,
  createdBy: string
) {
  const isExpired = daysUntilExpiry <= 0;
  const alertData = {
    alertId: `ALERT-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
    type: isExpired ? AlertType.EXPIRED_PRODUCT : AlertType.EXPIRY_WARNING,
    priority: isExpired ? AlertPriority.CRITICAL :
              daysUntilExpiry <= 1 ? AlertPriority.HIGH :
              daysUntilExpiry <= 3 ? AlertPriority.MEDIUM : AlertPriority.LOW,
    productId,
    locationId,
    batchId,
    expiryDate,
    createdBy,
    autoGenerated: true,
    metadata: { daysUntilExpiry }
  };
  
  return this.create(alertData);
};

InventoryAlertSchema.statics.dismissOldAlerts = function(productId: string, type: AlertType, locationId?: string) {
  const query: any = { productId, type, isActive: true };
  if (locationId) query.locationId = locationId;
  
  return this.updateMany(query, {
    isActive: false,
    metadata: { dismissedAt: new Date(), reason: 'Auto-dismissed by new alert' }
  });
};

// Virtuals
InventoryAlertSchema.virtual('isOverdue').get(function() {
  if (!this.isActive || this.isAcknowledged) return false;
  
  const hoursOld = (Date.now() - this.createdAt.getTime()) / (1000 * 60 * 60);
  const maxHours = this.priority === AlertPriority.CRITICAL ? 2 :
                   this.priority === AlertPriority.HIGH ? 8 :
                   this.priority === AlertPriority.MEDIUM ? 24 : 72;
  
  return hoursOld > maxHours;
});

InventoryAlertSchema.virtual('ageInHours').get(function() {
  return Math.floor((Date.now() - this.createdAt.getTime()) / (1000 * 60 * 60));
});

InventoryAlertSchema.virtual('hasBeenNotified').get(function() {
  return this.notificationsSent.email || this.notificationsSent.push || this.notificationsSent.inApp;
});

InventoryAlertSchema.virtual('priorityScore').get(function() {
  const scores = {
    [AlertPriority.LOW]: 1,
    [AlertPriority.MEDIUM]: 2,
    [AlertPriority.HIGH]: 3,
    [AlertPriority.CRITICAL]: 4
  };
  return scores[this.priority] || 1;
});

// Configurar virtuals en JSON
InventoryAlertSchema.set('toJSON', { virtuals: true });
InventoryAlertSchema.set('toObject', { virtuals: true });

// Crear y exportar el modelo
const InventoryAlert = mongoose.models.InventoryAlert ||
  mongoose.model<IInventoryAlert>('InventoryAlert', InventoryAlertSchema);

export default InventoryAlert;
export { InventoryAlertSchema };